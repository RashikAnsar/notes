(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{105:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return u}));var n=a(0),i=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=i.a.createContext({}),d=function(e){var t=i.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):c(c({},t),e)),a},b=function(e){var t=d(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,s=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),b=d(a),m=n,u=b["".concat(s,".").concat(m)]||b[m]||p[m]||r;return a?i.a.createElement(u,c(c({ref:t},l),{},{components:a})):i.a.createElement(u,c({ref:t},l))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,s=new Array(r);s[0]=m;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:n,s[1]=c;for(var l=2;l<r;l++)s[l]=a[l];return i.a.createElement.apply(null,s)}return i.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"},160:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/OOPs-e438a70fd92d79d098a7a3f72cd29cdc.svg"},99:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return c})),a.d(t,"toc",(function(){return o})),a.d(t,"default",(function(){return d}));var n=a(3),i=a(7),r=(a(0),a(105)),s={id:"oops",title:"Object-Oriented Programming",sidebar_label:"Object-Oriented Programming"},c={unversionedId:"lang/oops",id:"lang/oops",isDocsHomePage:!1,title:"Object-Oriented Programming",description:"Introduction",source:"@site/notes/lang/oops.md",slug:"/lang/oops",permalink:"/notes/lang/oops",editUrl:"https://github.com/rashikansar/notes/edit/main/notes/lang/oops.md",version:"current",lastUpdatedBy:"Rashik Ansar",lastUpdatedAt:1616240762,sidebar_label:"Object-Oriented Programming",sidebar:"lang",previous:{title:"C++",permalink:"/notes/lang/cpp"},next:{title:"Standard Template Library",permalink:"/notes/lang/stl"}},o=[{value:"Introduction",id:"introduction",children:[]},{value:"Advantages of OOP",id:"advantages-of-oop",children:[]},{value:"Class",id:"class",children:[{value:"Data Members",id:"data-members",children:[]},{value:"Methods :",id:"methods-",children:[]},{value:"Constructor and Destructor",id:"constructor-and-destructor",children:[]},{value:"Shallow Copy vs Deep Copy",id:"shallow-copy-vs-deep-copy",children:[]}]},{value:"Object",id:"object",children:[]},{value:"Encapsulation",id:"encapsulation",children:[{value:"Getters and Setters",id:"getters-and-setters",children:[]}]},{value:"Abstraction",id:"abstraction",children:[]},{value:"Inheritance",id:"inheritance",children:[{value:"Multiple Inheritance",id:"multiple-inheritance",children:[]},{value:"Diamond Problem",id:"diamond-problem",children:[]},{value:"Access modifiers  and inheritance",id:"access-modifiers--and-inheritance",children:[]},{value:"Virtual Functions",id:"virtual-functions",children:[]},{value:"Pure Virtual Functions (or) Abstract Classes",id:"pure-virtual-functions-or-abstract-classes",children:[]}]}],l={toc:o};function d(e){var t=e.components,s=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},l,s,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"introduction"},"Introduction"),Object(r.b)("p",null,"C++ is a combination of a procedural and an object-oriented language. Object-Oriented programming is a programming paradigm that relies on the concept of classes and objects. OOP is based on the notion that you should divide your program not into tasks, but into models of physical objects. While this seems abstract at first, it becomes clearer when you consider physical objects in terms of their classes, components, properties, and behaviors."),Object(r.b)("p",null,Object(r.b)("img",{alt:"OOPs",src:a(160).default})),Object(r.b)("h2",{id:"advantages-of-oop"},"Advantages of OOP"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"OOPs is closer to real world model."),Object(r.b)("li",{parentName:"ol"},"Hierarchical relationship among objects can be well-represented through inheritance."),Object(r.b)("li",{parentName:"ol"},"Data can be made hidden or public as per the need. Only the necessary data is exposed enhancing the data security."),Object(r.b)("li",{parentName:"ol"},"Increased modularity adds ease to program development."),Object(r.b)("li",{parentName:"ol"},"Private data is accessible only through designed interface in a way suited to the program.")),Object(r.b)("h2",{id:"class"},"Class"),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The main difference between a ",Object(r.b)("inlineCode",{parentName:"p"},"class")," and a ",Object(r.b)("inlineCode",{parentName:"p"},"struct")," is that a struct's member variables and methods are ",Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"public")),", while a class's member variables and methods are ",Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"private")),"."))),Object(r.b)("p",null,"Class is a blueprint from which objects are created. In C++, new types are mostly created using a class. To write object-oriented programs, we need to create a class, as a type, and then instantiate objects as instances of that type."),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"classes dont consume any space."))),Object(r.b)("p",null,"A class in C++ contains"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Data memebers: are the properties/attributes of class"),Object(r.b)("li",{parentName:"ol"},"Methods: are the behaviours of the class"),Object(r.b)("li",{parentName:"ol"},"Constructor: It's used to create instances of class (Object)")),Object(r.b)("h3",{id:"data-members"},"Data Members"),Object(r.b)("p",null,"Data members are the properties that are present in a class. The type of these properties can be modified by the use of special keywords called modifiers. Let us build our own student class and learn about them."),Object(r.b)("h4",{id:"static-and-non-static-properties-"},"Static and Non Static Properties :"),Object(r.b)("p",null,"Static properties are those that are common to all objects and belong to the class rather each specific object. So each object that we create doesn\u2019t have their copy. They are shared by all the objects of the class. We need to write the static keyword before it in order\nto make it static."),Object(r.b)("p",null,"An important point to note is that whenever we create a new object only the non static data member copies are created and the static properties are stored within the class only! This could be considered a very memory efficient practice as static members of a class are made only once."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="static_non_static_props.cpp"',title:'"static_non_static_props.cpp"'}),"// create a class named Student\nclass Student{\n  // Static property num of students in class\n  static int numStudents;\n  //  Non-static properties\n  char name[10];\n  int rollNo;\n};\n")),Object(r.b)("h4",{id:"access-modifiers"},"Access Modifiers"),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"When there is no access modifier for a data member, it is private by default."),Object(r.b)("p",{parentName:"div"},"The instance member functions(methods) of a class are normally set to public."))),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Private:")," If we make any data member as private it is visible only within the class i.e. it can be accessed by and through the methods of the same class. So we can provide setters and getters function through which they can be accessed outside the class"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Protected:")," It is only accesible within the class and sub-class"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Public:")," It is accesible everywhere")),Object(r.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"It is better to make a variable private and then provide getters and setters in case we wish to allow others to view and change it than making the variable public. Because by providing setter we can actually add constraints to the function and update value only if\nthey are satisfied"))),Object(r.b)("h3",{id:"methods-"},"Methods :"),Object(r.b)("p",null,"The second part of the class definition declares the member functions of the class; that is, it declares all functions that are used to simulate the behavior of the class. The methods are called on the object name by using the dot operator."),Object(r.b)("h4",{id:"static-vs-non-static-methods"},"Static v/s Non Static Methods"),Object(r.b)("p",null,"Like data members, methods of a class can also be static which means those methods belong to the class rather than the objects for the class. These methods are directly called by the class name."),Object(r.b)("p",null,"As the static methods belong to a class we don\u2019t need any instance of a class to access them. An important implication of this point is that the non static properties thus can\u2019t be accessed by the static methods as there is no specific instance of the class associated with them (the non static properties are specific to each object). So, non static members and the \u2018this\u2019 keyword can\u2019t be used with the static functions. Thus these methods are generally used for the static properties of the class only!"),Object(r.b)("p",null,"The non static methods on the other hand are called on an instance of a class or an object and can thus access both static and non static properties present in the object. The access modifiers work the same with the methods as they do with the data members. The public methods can be accessed anywhere whereas the private methods are available only within the same class. Thus private methods can be used to work with the data members that we don\u2019t wish to expose to the clients."),Object(r.b)("h3",{id:"constructor-and-destructor"},"Constructor and Destructor"),Object(r.b)("p",null,"A constructor is a member function that creates an object when it is called and initializes the data members of an object when it is executed. The declaration of the data members in the class definition does not initialize the data members; the declaration just gives the names and the types of the data members"),Object(r.b)("p",null,"A constructor has two characteristics: It does not have a return value, and its name is the same as the name of the class. A constructor cannot have a return value (not even void) because it is not designed to return anything; its purpose is different. It creates an object and initializes the data members. Although we will see that a constructor may also do some other tasks, such as validation of values, these tasks are also considered part of the initialization."),Object(r.b)("p",null,"We can have three types of constructors in a class"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"parameter constructors"),Object(r.b)("li",{parentName:"ol"},"default constructors"),Object(r.b)("li",{parentName:"ol"},"copy constructors")),Object(r.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"caution")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The parameter constructor can be overloaded for a class but not other constructors."))),Object(r.b)("p",null,"Like a constructor, a destructor has two special characteristics. "),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"the name of the destructor is the name of the class preceded by a tilde symbol (",Object(r.b)("inlineCode",{parentName:"li"},"~"),"), but the tilde is added to the first name, not the last name (the last name is the same for all member functions). "),Object(r.b)("li",{parentName:"ol"},"Like a constructor, a destructor cannot have a return value (not even void) because it returns nothing. "),Object(r.b)("li",{parentName:"ol"},"A destructor can take no arguments, which means it cannot be overloaded.")),Object(r.b)("p",null,"A destructor is guaranteed to be automatically called and executed by the system when the object instantiated from the class goes out of scope. In other words, if we have instantiated five objects from the class, the destructor is automatically called five times to guarantee that all objects are cleaned up. Cleanup is most important if the constructed has called resources such as files. After the program is terminated, the allocated memory is recycled. "),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"A constructor is a special member function that creates and initializes an object."),Object(r.b)("p",{parentName:"div"},"A destructor is a special member function that cleans and destroys an object."))),Object(r.b)("p",null,"If any memory has been dynamically allocated, then the destructor of an object must free this memory by using delete or delete[], depending on the data type. If a class allocates memory dynamically, an explicit destructor should be created to ensure that this memory is freed correctly."),Object(r.b)("h3",{id:"shallow-copy-vs-deep-copy"},"Shallow Copy vs Deep Copy"),Object(r.b)("p",null,"Shallow copy, it runs through each member variable and assigns them the corresponding value of the object currently being copied. A shallow copy of an object copies all the members. This is ",Object(r.b)("strong",{parentName:"p"},"usually fine when all the members are values"),". But, when a shallow copy is enacted on a pointer to dynamic memory, only the pointer is copied, not the memory it points to. "),Object(r.b)("p",null,"The implicit default copy constructor does the shallow copy."),Object(r.b)("p",null,"To correctly handle the copy of our dynamically allocated memory, and we know that the compiler-generated copy constructor will not do this for us; we need to write our own."),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"When is a shallow copy not enough?"),Object(r.b)("p",{parentName:"div"},"When a class has dynamically allocated memory, a deep copy is usually\xa0needed."))),Object(r.b)("p",null,"If you need to define an ",Object(r.b)("strong",{parentName:"p"},"explicit copy constructor"),", then you will almost always need to also define an ",Object(r.b)("strong",{parentName:"p"},"explicit copy assignment operator"),"."),Object(r.b)("h2",{id:"object"},"Object"),Object(r.b)("p",null,"Object is the instance of the class. which will have the copy of the data members and methods that can be applied on the object."),Object(r.b)("p",null,"Lets see the example of the class and object"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="oop.cpp"',title:'"oop.cpp"'}),'#include <iostream>\n\nusing namespace std;\n\n// Class Definition\nclass Circle {\n  private:\n    double radius;\n  public:\n    Circle(double radius); // Parameter Constructor\n    Circle(); // Default Constructor\n    ~Circle(); // Destructor\n    Circle(const Circle& circle);\n\n    void set_radius(double radius); // Setter (Mutator)\n    double get_radius() const; // Getter (Accessor)\n    double get_area() const; // Getter (Accessor)\n    double get_perimeter() const; // Getter (Accessor)\n};\n\n// Constructors and Member Function (Methods) Definition\nCircle::Circle(double rds): radius(rds) {\n  cout << "The parameter constructor was called. " << endl;\n}\n\nCircle::Circle(): radius(0.0) {\n  cout << "The default constructor was called. " << endl;\n}\n\nCircle::Circle(const Circle& circle): radius(circle.radius) {\n  cout << "The copy constructor was called. " << endl;\n}\n\nCircle:: ~Circle() {\n  cout << "The destructor was called for circle with radius :" << radius << endl;\n}\n\nvoid Circle:: set_radius(double value) {\n  radius = value;\n}\n\ndouble Circle::get_radius() const {\n  return radius;\n}\n\ndouble Circle::get_area() const {\n  const double PI = 3.14;\n  return (PI * radius * radius);\n}\n\ndouble Circle::get_perimeter() const {\n  const double PI = 3.14;\n  return (2* PI * radius);\n}\n\nint main() {\n  // Object creation\n  Circle circle1(5.2);\n  cout << "Radius: " << circle1.get_radius() << endl;\n  cout << "Area: " << circle1.get_area() << endl;\n  cout << "Perimeter: " << circle1.get_perimeter() << endl;\n\n  Circle circle2(circle1);\n  cout << "Radius: " << circle2.get_radius() << endl;\n  cout << "Area: " << circle2.get_area() << endl;\n  cout << "Perimeter: " << circle2.get_perimeter() << endl;\n\n  Circle circle3;\n  cout << "Radius: " << circle3.get_radius() << endl;\n  cout << "Area: " << circle3.get_area() << endl;\n  cout << "Perimeter: " << circle3.get_perimeter() << endl;\n\n  return 0;\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-console",metastring:'title="output"',title:'"output"'}),"The parameter constructor was called.\nRadius: 5.2\nArea: 84.9056\nPerimeter: 32.656\nThe copy constructor was called.\nRadius: 5.2\nArea: 84.9056\nPerimeter: 32.656\nThe default constructor was called.\nRadius: 0\nArea: 0\nPerimeter: 0\nThe destructor was called for circle with radius: 0\nThe destructor was called for circle with radius: 5.2\nThe destructor was called for circle with radius: 5.2\n")),Object(r.b)("h2",{id:"encapsulation"},"Encapsulation"),Object(r.b)("p",null,"Encapsulation combines a class's data and the member functions to act on that data. Operations on data in a class should only be possible through the members that class provides; member data should not be directly\xa0accessible. This is also known as ",Object(r.b)("strong",{parentName:"p"},"data-hiding"),"."),Object(r.b)("p",null,"We can apply encapsulation design to our class by using ",Object(r.b)("inlineCode",{parentName:"p"},"access-modifiers"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="encapsulation.cpp"',title:'"encapsulation.cpp"'}),'#include <iostream>\n\nusing namespace std;\n\nclass Person {\n private:\n  string m_name;\n  int m_age;\n\n public:\n  Person(string name, int age) {\n    m_name = name;\n    m_age = age;\n  }\n\n  void print() {\n    cout << "My name is: " << m_name << " and I\'m " << m_age << " years old."\n         << endl;\n  }\n};\n\nint main() {\n  Person p("John Doe", 20);\n  p.print();\n  return 0;\n}\n')),Object(r.b)("p",null,"In the above example you can see that we cannot directly access the data members but we can access via member functions (methods) like ",Object(r.b)("inlineCode",{parentName:"p"},"print")," and constructor itself to initialize values."),Object(r.b)("h3",{id:"getters-and-setters"},"Getters and Setters"),Object(r.b)("p",null,"A common technique for protecting data while still allowing sensible access is to use getters and setters. Unsurprisingly, a getter gets data and a setter sets data. Getters are commonly prefixed with the word ",Object(r.b)("inlineCode",{parentName:"p"},"get")," and setters with the word ",Object(r.b)("inlineCode",{parentName:"p"},"set"),"."),Object(r.b)("p",null,"Setters allow the setting of some data. It is worth noting that a direct setter will essentially break encapsulation as it exposes the variable to be changed again. One thing that a setter allows that a publicly exposed member variable does not is the validation of the data to be set."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="settersGetters.cpp"',title:'"settersGetters.cpp"'}),'#include <cmath>\n#include <iostream>\n\nclass Position {\n public:\n  Position(float x, float y) : m_x(x), m_y(y) {}\n\n  float distance(float x, float y) {\n    float xDiff = x - m_x;\n    float yDiff = y - m_y;\n    return std::sqrt(((xDiff * xDiff) + (yDiff * yDiff)));\n  }\n\n  float getX() { return m_x; }\n  float getY() { return m_y; }\n  void setX(float x) { m_x = x; }\n  void setY(float y) { m_y = y; }\n\n private:\n  float m_x;\n  float m_y;\n};\n\nint main() {\n  float maxDistance = 500.0f;\n  Position pos(10.0f, 20.0f);\n  Position pos2(100.0f, 200.0f);\n  bool validDistance = true;\n  int numberOfTimesMoved = 0;\n\n  while (validDistance) {\n    float distance = pos.distance(pos2.getX(), pos2.getY());\n\n    if (distance > maxDistance) {\n      validDistance = false;\n      break;\n    }\n\n    // get direction\n    float xDirection = pos2.getX() - pos.getX();\n    float yDirection = pos2.getY() - pos.getY();\n\n    // normalize\n    float normalizedX = xDirection / distance;\n    float normalizedY = yDirection / distance;\n    pos.setX(pos.getX() - normalizedX);\n    pos.setY(pos.getY() - normalizedY);\n    numberOfTimesMoved++;\n  }\n\n  std::cout << "Too far apart."\n            << " Moved " << numberOfTimesMoved << " times";\n\n  return 0;\n}\n')),Object(r.b)("h2",{id:"abstraction"},"Abstraction"),Object(r.b)("p",null,"Abstraction and encapsulation are two sides of the same coin. Encapsulating data inside a class allows functionality on that data to be abstracted away, only exposing the methods the class design needs to make the class functional to a user and hiding all the nitty-gritty implementation details the class performs on its member data."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Abstraction provides only an essential interface to the user and hides the background details.")),Object(r.b)("h2",{id:"inheritance"},"Inheritance"),Object(r.b)("p",null,"When declaring a class in C++, we have the ability to inherit from another class. In fact, we can inherit from multiple classes at the same time\u2014a feature of C++ that not all object-oriented languages share. When we inherit from another class, we gain all its members that have either public or protected privacy modifiers. Private members remain visible only to the class in which they're defined, not the inheriting class. "),Object(r.b)("p",null,"This is one of the fundamental concepts in OOP and allows us to build flexible, maintainable objects where common functionality can be declared only once, then implemented and extended where needed."),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"If we want to prohibit a class from being inherited from, C++11 provides us with the ",Object(r.b)("inlineCode",{parentName:"p"},"final")," keyword."),Object(r.b)("p",{parentName:"div"},Object(r.b)("inlineCode",{parentName:"p"},"class ClassName final {};")))),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="inheritance.cpp"',title:'"inheritance.cpp"'}),'\n#include <iostream>\n\nclass Shape {\n public:\n  int area = 10;\n  int GetArea() { return area; }\n};\n\nclass Square : public Shape {};\nclass Circle : public Shape {};\nclass Triangle : public Shape {};\n\nint main() {\n  Square mySquare;\n  Circle myCircle;\n  Triangle myTriangle;\n\n  mySquare.area = 5;\n  std::cout << "Square Area: " << mySquare.GetArea() << std::endl;\n\n  myCircle.area = 15;\n  std::cout << "Circle Area: " << myCircle.GetArea() << std::endl;\n\n  std::cout << "Triangle Area: " << myTriangle.GetArea() << std::endl;\n  return 0;\n}\n')),Object(r.b)("h3",{id:"multiple-inheritance"},"Multiple Inheritance"),Object(r.b)("p",null,"A single derived class can inherit variables and functionality from multiple base classes to create a more complex object."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="multipleInheritance.cpp"',title:'"multipleInheritance.cpp"'}),'#include <iostream>\n\nclass Color {\n public:\n  std::string color = "";\n  std::string GetColor() { return color; }\n};\n\nclass Shape {\n public:\n  int area = 10;\n  int GetArea() { return area; }\n};\n\nclass Square : public Shape, public Color {};\n\nclass Circle : public Shape, public Color {};\n\nclass Triangle : public Shape, public Color {};\n\nint main() {\n  Square mySquare;\n  Circle myCircle;\n  Triangle myTriangle;\n  mySquare.area = 5;\n  mySquare.color = "red";\n  std::cout << "Square Area: " << mySquare.GetArea() << std::endl;\n  std::cout << "Square Color: " << mySquare.GetColor() << std::endl;\n  myCircle.area = 10;\n  myCircle.color = "blue";\n  std::cout << "Circle Area: " << myCircle.GetArea() << std::endl;\n  std::cout << "Circle Color: " << myCircle.GetColor() << std::endl;\n  myTriangle.area = 15;\n  myTriangle.color = "green";\n  std::cout << "Triangle Area: " << myTriangle.GetArea() << std::endl;\n  std::cout << "Triangle Color: " << myTriangle.GetColor() << std::endl;\n}\n')),Object(r.b)("h3",{id:"diamond-problem"},"Diamond Problem"),Object(r.b)("p",null,"It's named after the shape of its inheritance diagram. Where two classes (B, C) inherit from one Class (A) and a class(D) inherits from both classes (B and C) the resultant class will have two copies of everythin within class(A)."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"The result of a class inheriting from two base classes that share a common base themselves.")),Object(r.b)("p",null,"This can be avoided in two ways:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"First is to qualify which version of the variable you want to access (",Object(r.b)("inlineCode",{parentName:"li"},"B::DataMember = 1"),")"),Object(r.b)("li",{parentName:"ol"},"Through the use of virtual inheritance. When we use the virtual keyword when inheriting from a class, we ensure that only one copy of our base class's member variables will be inherited by any derived classes")),Object(r.b)("p",null,"This avoids duplicate properties and mitigates the diamond problem."),Object(r.b)("h3",{id:"access-modifiers--and-inheritance"},"Access modifiers  and inheritance"),Object(r.b)("p",null,"There are two areas of accessibility we need to be aware of when making use of inheritance. The first is the accessibility of the members in our base class, and the second is the access modifier we define when inheriting from a class. "),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Base Class"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Derived access with public inheritance"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Derived access with protected inheritance"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Derived access with private inheritance"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"public"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"public"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"protected"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"private")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"protected"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"protected"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"protected"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"private")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"private"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"private"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"private"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"private")))),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"The most restrictive modifier wins.")),Object(r.b)("p",null,"Whenever two different modifiers are combined (such as a protected base class variable being inherited privately) it's the most restrictive modifier that sticks; in that case, it would be private"),Object(r.b)("p",null,"Understanding how different access modifiers affect inheritance is important, and often, a cause of confusion."),Object(r.b)("p",null,"All variables, regardless of the access modifier, are fully visible to the class in which they are defined. Derived classes (those that inherit from a base class) can access public and protected members. Finally, the access modifier used when inheriting from the base class determines the final visibility of the members, and therefore, how all other classes can access them."),Object(r.b)("h3",{id:"virtual-functions"},"Virtual Functions"),Object(r.b)("p",null,"In C++, a virtual function is one that can have its functionality overridden by a derived class. To mark a function as virtual, we simply use the ",Object(r.b)("inlineCode",{parentName:"p"},"virtual")," keyword at the start of its\xa0declaration."),Object(r.b)("p",null,"This is done, first, by declaring a function with the same signature, return type, name, and the override keyword and then by defining it. "),Object(r.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Overriding virtual functions will work just fine without ",Object(r.b)("inlineCode",{parentName:"p"},"override")," identifier, but it's good practice to include it."),Object(r.b)("p",{parentName:"div"},"Unlike virtual, override is not a keyword. It is instead an identifier with special meaning. It has no special meaning outside of the context of virtual functions."))),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="overriding.cpp"',title:'"overriding.cpp"'}),'#include <iostream>\n\nusing namespace std;\n\nclass MyBaseClass {\n public:\n  virtual void printMessage() {\n    cout << "Hello" << endl; \n  }\n};\n\nclass MyDerivedClass : public MyBaseClass {\n public:\n  void printMessage() override {\n    cout << "World!" << endl; \n  }\n};\n\nint main() {\n  MyDerivedClass d;\n  d.printMessage();\n  return 0;\n}\n')),Object(r.b)("p",null,"In our overriding function, we can make a call to the base function through our base class type. This will run the logic defined in the base version of the function before running that of the overriding function."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="updatedSnippet.cpp"',title:'"updatedSnippet.cpp"'}),'class MyDerivedClass : public MyBaseClass {\n public:\n  void printMessage() override {\n\n    // Added this line in above code.\n    MyBaseClass::printMessage();\n    \n    cout << "World!" << endl; \n  }\n};\n')),Object(r.b)("h3",{id:"pure-virtual-functions-or-abstract-classes"},"Pure Virtual Functions (or) Abstract Classes"),Object(r.b)("p",null,"Overriding a normal virtual function is optional; however, if we want to force our users to implement a virtual function in the derived class, we can make it pure virtual in the base class. A pure virtual function does not have an implementation in the base class, it is merely declared. "),Object(r.b)("p",null,"Syntax: ",Object(r.b)("inlineCode",{parentName:"p"},"virtual   void   MyFunction()   =   0;")),Object(r.b)("p",null,"If we don't want to provide a definition in the base class, but still want to make overriding the function optional, we can give it an empty body. Since we've given it an empty body, the class does not become abstract."),Object(r.b)("p",null,"Syntax: ",Object(r.b)("inlineCode",{parentName:"p"},"virtual   void   MyFunction() {};")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"When a class contains one or more pure virtual functions, it becomes an abstract class.This is a class that cannot be directly instantiated.")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp",metastring:'title="virtualFunctions.cpp"',title:'"virtualFunctions.cpp"'}),'#include <iostream>\n#include <string>\n\n// abstract class Shape\nclass Shape {\n public:\n  virtual int CalculateArea() = 0;\n\n protected:\n  int area = 0;\n};\n\nclass Square : public Shape {\n public:\n  int height = 0;\n\n  int CalculateArea() override {\n    area = height * height;\n    return area;\n  }\n};\n\nclass Circle : public Shape {\n public:\n  int radius = 0;\n\n  int CalculateArea() override {\n    area = 3.14 * (radius * radius);\n    return area;\n  }\n};\n\nint main() {\n  Square square;\n  square.height = 10;\n  std::cout << "Square Area: " << square.CalculateArea() << std::endl;\n  Circle circle;\n  circle.radius = 10;\n  std::cout << "Circle Area: " << circle.CalculateArea() << std::endl;\n}\n')))}d.isMDXComponent=!0}}]);